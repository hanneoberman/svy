---
title: "R Notebook"
author:
- Sanne Meijering
- Hanne Oberman
- Gerbrich Ferdinands
output: pdf_document
---

# Initialization
```{r}
# Load packages
require(survey)
require(sampling)
require(dplyr)
require(MASS)

# Load society dataset
society <- readRDS("Understanding Society innovation pnel wave A.RDS")

# Remove unnecessary columns
# society <- society[,-c(2,3,6,7,15:52, 61, 63, 64, 66:75, 78:80, 82:86, 90, 91, 93)]

# Change variable types
society$a_dvage <- as.numeric(society$a_dvage)
```

# Sampling design

## Question 2
Investigation of design weights

```{r}
# Calculate variance of design weight
Var <- var(society$a_psnenip_xd)
# Combine variance with other descriptive statistics
Descr <- cbind(t(summary(society$a_psnenip_xd)), Var)
# Print with up to 2 decimals
round(Descr, 2)

# Create histogram of design weight values
hist(society$a_psnenip_xd, 
     breaks = 8,
     main = NULL, #"Histogram of design weight variable 'a_psnenip_xd'",
     xlab = "Value of the design weight")
```

## Question 3
```{r}
# Investigate levels of government office region variable
levels(society$a_gor_dv)
nrow(society[society$a_gor_dv == "missing",])
nrow(society[society$a_gor_dv == "northern ireland",])
# None of the value are missing or northern ireland, so those can be ignored

# Run linear regression
coeff <- with(society, lm(a_psnenip_xw ~ a_psnenip_xd + a_sex + a_dvage + a_gor_dv))

# Get and sort coefficients
coeff <- coeff$coefficients
coeff.gor <- sort(coeff[5:15])

# Plot coefficients
plot(coeff.gor, xlab = "Government Region", ylab = "Coefficient")

# Show coefficients
coeff.gor
```

In accordance with the data, Scotland, London and the West Midlands form one category each, with the fourth category containing all other areas.

```{r}
# Gather grouped region in one variable
society$gor_groups <- "England_Wales"
society$gor_groups[society$a_gor_dv=="london"] <- "London"
society$gor_groups[society$a_gor_dv == "scotland"] <- "Scotland"
society$gor_groups[society$a_gor_dv == "west midlands"] <- "West Midlands"

# Change government office region groups and age into factors
society$gor_groups <- as.factor(society$gor_groups)
society$age_fac <- as.factor(society$a_dvage)

# Rerun linear regression
coeff2 <- with(society, lm(a_psnenip_xw ~ a_psnenip_xd + a_sex + gor_groups + age_fac))

# Get coefficients
coeff2 <- coeff2$coefficients
coeff2.age <- coeff2[7:102]

# Change names of coefficients into numbers
x <- unlist(strsplit(names(coeff2.age), "age_fac"))
names(coeff2.age) <- x[x!=""]

# Plot coefficients
plot(as.numeric(names(coeff2.age)), coeff2.age)
for (i in seq(10,110,10)+0.5){
 abline(v=i, col="red") 
}

```

In accordance with the results, age is split up in sections of 10 years, with the 0-10 and 11-20 as well as the 51-60 and 61-79 categories combined and all people of age 81 and older placed into one group.

```{r}
# Assign the levels
levels(society$age_fac) <- c(rep("group0_20", 15), rep("group21_30", 10), 
                               rep("group31_40", 10), rep("group41_50",10), 
                               rep("group51_70", 20), rep("group71_80", 10), 
                               rep("group_80", 22))

# Create table
with(society, table(age_fac,gor_groups))
# None of the groups has zero observations

# Run linear regression again
coeff3 <- with(society, lm(a_psnenip_xw ~ a_psnenip_xd + a_sex + gor_groups + age_fac))

#Get coefficients
coeff3 <- coeff3$coefficients
coeff3
```

# Population Estimates
## Question 4
```{r}
# Investigate the a_employ variable.
levels(society$a_employ[society$a_dvage > 15 & society$a_dvage < 64])
# The variable a_employ has seven levels.

summary(society$a_dvage[society$a_employ=="yes"])
summary(society$a_dvage[society$a_employ=="no"])
# Yes and no contain people of over 21 years of age.

nrow(society[society$a_employ=="missing",])
nrow(society[society$a_employ=="proxy respondent",])
# Missing and proxy respondent do not appear in the data

summary(society$a_dvage[society$a_employ=="inapplicable"])
# Inapplicable seems to contain all children and youths of 21 years and younger
# It cannot be assumed that none of them is employed. It can however be assumed that only a
# small part of them is employed, as children under 15 cannot be employed legally
# and most would still be going to a school or university.

nrow(society[society$a_employ=="refuse",])
nrow(society[society$a_employ=="don\'t know",])
# Both refuse and don't know contain one row. These can be treated as missing data.

# Thus, our goal is to compare the proportion of employed people (yes) of working age against 
# the number of unemployed people (no, inapplicable), excluding the missing data (refuse, don't know)

with(society, nrow(society[a_employ=="yes" & a_dvage >64,]))
# There are people older than 64 still working, we should exclude those. 
with(society, nrow(society[a_employ=="yes" & a_dvage <15,]))
# No one younger than 15 years is reported to be working, which is to be expected as it was not
# a question asked to people under 21 years of age.

# Since we wish to know the proportion of employed people of working age, we need 2 groups, one with employed adults and one with unemployed people and employed elderly.
society$employ_dv <- as.numeric(0)
society$employ_dv[society$a_employ=='yes' & society$a_dvage <= 65] <- 1

# Create design
# Don't remove the missing values yet, as the weights are calculated including missing values 
Design <- svydesign(ids=~a_hidp, strata=~a_strata, data=society, weights=~a_psnenip_xw)
# Make a subset of non-missing values
Nonmiss <- with(Design, subset(Design, a_employ!="refuse" & a_employ!="don\'t know"))
svymean(~employ_dv, Nonmiss)
confint(svymean(~employ_dv, Nonmiss))
# 43,3% of the population is employed, with a 95% confidence interval of 41.4%-45.2%
```

## Question 5b
```{r}
# Inspect levels of variables
levels(society$a_livesp_dv)
levels(society$a_cohab_dv)
levels(society$a_single_dv)
levels(society$a_mastat_dv)

###### HOUSEHOLD SIZE PER HOUSEHOLD
# a_hidp - Household identifier
# Household size: count for each household, how many persons there are in.
# Get household size per household
count <- as.matrix(table(society$a_hidp))
summary(count)
# Turn into dataframe and join to society 
households <- data.frame(a_hidp=as.numeric(rownames(count)), hh_size=count)

##### NUMBER OF CHILDREN PER HOUSEHOLD
# Count the number of kids under the age of 16 using the mastat variable
for(i in households$a_hidp){
  hh <- society[society$a_hidp==i,]
  households$n_child[households$a_hidp==i]=as.numeric(table(hh$a_mastat_dv)["Child under 16"])
}

##### ANY CHILDREN IN HOUSEHOLD
# Create variable whether the household has children in it (True for households with children)
households$with_child <- households$n_child > 0

##### ANY SINGLE ADULTS IN HOUSEHOLD
# Create variable whether the person is a single adult (true) or not (false)
society$single_adult <- society$a_single_dv == "Yes" & society$a_dvage >= 16
# Create variable whether there is a single adult in the household
for(i in households$a_hidp){
  households$hasSingle[households$a_hidp==i] <- any(society$single_adult[society$a_hidp==i])
}

##### ANY COUPLES IN HOUSEHOLD
# Create variable whether the person is in a couple (true) or not (false)
society$inacouple <- society$a_livesp_dv == "Yes" | society$a_cohab_dv == "Yes"
# Create variable whether there is a couple in the household
for(i in households$a_hidp){
  households$hasCouple[households$a_hidp==i] <- any(society$inacouple[society$a_hidp==i])
}

##### HOUSEHOLD TYPE 
# Create matrix containing household states
household_states <- matrix(c("Couple with children", "Couple without children", 
                             "Single with children", "Single without children"), nrow=2)
# Create household info variable
households$hh_type <- ""

for (i in seq(1,nrow(households))){
  # Get right row of household state
  if (households$with_child[i]){
    child = 1
  }
  else child = 2
  
  # Get right column of household state
  if(households$hasCouple[i]){
    state = 1
  }
  else if(households$hasSingle[i]){
    state = 2
  }
  # Select household state and put in households$hh_type
  households$hh_type[i] <- household_states[child, state]
}

# Show how many of each category there are
table(households$hh_type)

# Join to society dataset
society <- left_join(society, households, by="a_hidp")

# update sampling design 
Design <- svydesign(ids=~a_hidp, strata=~a_strata, data=society, weights=~a_psnenip_xw)
```

## Question 5d
```{r}
tab <- svytable(~a_agegr5_dv + hh_type, Design) # creates a contingency table of 
# The Ntotal argument can be either a single number or a data frame whose first column gives the (first-stage) sampling strata and second column the population size in each stratum. In this second case the svytable command performs ???post-stratification???: tabulating and scaling to the population within strata and then adding up the strata.
summary(tab)
# plot the relationshp between age categories and household types. 
plot(tab, xlab = "age categories", ylab = "household types", col=c("steelblue1","sienna1","plum2","goldenrod1"))

# add percentages

# BLUE = couple with children
# PINK = single parent with children
# ORANGE = couple without children 
# YELLOW = single without children 
```
## Question 6
```{r}
# Summarise a_ivfio
(summary <- summary(society$a_ivfio))
summary[summary != 0]
adults <- sum(society$a_ivfio == "Full interview") #the full interviews with adults
youths <- sum(society$a_ivfio ==  "Youth Interview") #the interviews with children
sum(adults, youths) #all personally completed interviews

# The nonresponse indicator is 1 for all (partial) nonresponse and 0 for full (youth) interviews
society$NR <- 1
society$NR[society$a_ivfio == "Youth Interview"] <- 0
society$NR[society$a_ivfio == "Full interview"] <- 0
```


## Question 7
```{r}
# Further investigate the level Language difficulties
society$a_iproxy[society$a_ivfio=="Language difficulties"]
# It's clearly a complete nonresponse

# Repeat creation of model design from Q4 so NR variable is included
Design <- svydesign(ids=~a_hidp, strata=~a_strata, data=society, weights=~a_psnenip_xw)
Nonmiss <- with(Design, subset(Design, a_employ!="refuse" & a_employ!="don\'t know"))
# Create model
I_personal <- with(Nonmiss, subset(Nonmiss, NR==0))
                   
# Calculate nonresponse
svymean(~employ_dv, I_personal)
confint(svymean(~employ_dv, I_personal))
```

## Question 8
```{r}
# Investigate the nonresponse
mean(society$NR) # compute proportion nonresponders
# Look at levels of household response
summary(society$a_hhresp_dv) 
# All households at least filled in the grid, so we only look into person (unit) nonresponse.
# use design weights, 
NRdesign <- svydesign(ids=~a_hidp, strata=~a_strata, data=society, weights=~ )

# model with all predictors
fullmodel <- glm(NR ~ 
                   a_gor_dv + a_urban_dv + a_sex + a_racel_dv + 
                   a_employ + a_ageest + a_ageif + a_dvage + a_agegr5_dv + a_agegr10_dv + a_agegr13_dv + 
                   a_marstat + a_livesp +  a_livewith + a_adresp15 + a_adresp17 + a_livesp_dv + a_cohab_dv +
                   a_single_dv + a_mastat_dv + a_depchl_dv + a_rach16_dv + a_respm16_dv + a_respf16_dv + 
                   a_nchild_dv + a_ndepchl_dv + 
                   hh_type + hh_size + n_child # three self-constructed variables of household composition
                   # don't forget to include self-made variables:
                   #household_type + household_size + children
                   , family = binomial, data = society)
# this returns "glm.fit" fitted probabilities numerically 0 or 1 occurred. 

#### The following variables are excluded  :
# - ageest, a_dvage and ageif: Not informative, too many inapplicables. a_agegr5_dv, agegr10_dv & agegr13_dv are the remaining age variables in the model. 
# - a_adresp15 and a_adresp17 > these are PNOs and thus useless for prediction
# - a_ndepchl_dv > Same as a_nchild_dv, but with the Department for Work and Protection's definition of 'dependent'
# - a_marstat > a_mastat_dv contains the same information, but with fewer levels
# -  a_livewith > a_livewith_dv contains the same information, but with unmarried people being 'no' instead of 'inapplicable' > maybe switch?
# - a_livesp + a_livesp_dv + a_cohab_dv + a_single_dv + a_mastat_dv + a_depchl_dv + a_rach16_dv + a_respm16_dv + a_respf16_dv + a_nchild_dv # why they produce errors?

halffullmodel <- glm(NR ~ 
                        a_gor_dv + a_urban_dv + a_sex + a_racel_dv + 
                        a_employ + a_agegr5_dv + a_agegr10_dv + a_agegr13_dv + 
                        a_livesp + a_livesp_dv + a_cohab_dv +
                        a_single_dv + a_mastat_dv + a_depchl_dv + a_rach16_dv + a_respm16_dv + a_respf16_dv + 
                        a_nchild_dv + 
                        hh_type + hh_size + n_child # three self-constructed variables of household composition
                        ,family = binomial, data = society)
## still produces errors:
# Hannes model doesn't:
halffullmodel <- glm(NR ~ 
  a_gor_dv + a_urban_dv + a_sex + a_racel_dv +
  a_employ + a_agegr5_dv + a_agegr10_dv + a_agegr13_dv + 
  hh_size + n_child + hh_type
  ,family = binomial, data = society)

# model without any predictors
emptymodel <- nothing <- glm(NR ~ 
                             1,
                             family=binomial, data = society )

# backwards selection
backwards <- step(fullmodel)
halfbackwards <- step(halffullmodel)

# forwards selection to compare backwards model with it. 
forwards <- step(emptymodel,
scope=list(lower=formula(emptymodel),upper=formula(fullmodel)), direction="forward")

halfforwards <- step(emptymodel,scope=list(lower=formula(emptymodel),
  upper=formula(halffullmodel)), direction="forward")

# show different models: 
formula(fullmodel)
formula(backwards)
formula(forwards)
formula(halfforwards)
formula(halffullmodel)
formula(halfbackwards)

# dive deeper into halfbackwards since this is our model of interest
summary(halfbackwards)
# significant variables are a_agegr13, hh_size, hh_type, sex, urban and a_gor
# significant with p < .001 are sex, a_agegr13_dv and hh_size. plot those (see below)

# evaluate fit 
fit <- anova(halfbackwards, halffullmodel)
library(lmtest)
test <- lrtest(halfbackwards,halffullmodel)

# interesting: a_agegr13_dv produces NA's for every category except 16-17 and 18-19 years old..? 
# i tried to load all kinds of packages to compute a pseudo r squared but they didn't work.. 

# plot nonresponse 
tbl <- table(society$NR)
t1 <- tbl/3600*100 

# plot relationship sex / nonresponse 
t2 <- table(as.matrix(society$a_sex),as.matrix(society$NR)) # females respond more often then males do 

plot(t2) 

# plot relationship age / nonresponse 
t3 <- table(society$a_agegr13_dv, society$NR)

plot(t3) # the higher the age category, the less nonresponse.

# plot relationship hh_size / non response
t4 <- table(society$hh_size, society$NR) # the bigger the household, the more nonresponders 

plot(t4)
#### SANNES CODE (I LEFT IT IN IF YOU WANT TO COMPARE IT, OTHERWISE IT CAN BE DELETED. X GERBRICH)
#### Problematic variables:
# a_racel_dv > maybe fuse different backgrounds?
# a_employ > Only problematic for the two missing cases (remove those?)

# a_dvage > Children under ten are all counted as missing, as they were not interviewed (remove those?)
# Same problem with a_agegr5_dv, a_agegr10_dv. Also very similar, maybe take one?
# a_mastat_dv: Don't know == nonresponse (7 cases), seperated but legally married == response (55 cases)

# a_livewith: 2 cases of same-sex couples, maybe include in 'yes'?
# To change levels: 
# 1.Remove any variables with 0 observations to make things easier with:
# society$a_livewith <- factor(society$a_livewith)
# 2. Look at levels:
# levels(society$a_livewith)
# 3. Copy the levels, in the same order, and change the ones you want to change:
# levels(society$a_livewith) <- c("inapplicable", "yes", "no", "yes")
# Then the same-sex couples are under 'yes'

society[society$a_nchild_dv==6,]

# Possibly superfluous variables:
# a_dvage, a_agegr5_dv, a_agegr10_dv and a_agegr13_dv all include age
# a_rach16_dv is only about the primary caretaker: if there are two parents and one child, only one of the two will be primary caretaker

# Combine respm16_dv and respf16_dv
society$a_resp16_dv <- "No"
society$a_resp16_dv[society$a_respf16_dv == "Yes" | society$a_respf16_dv == "Yes"] <- "Yes" 

class(society$a_nchild_dv)
summary(society$a_nchild_dv)
with(society, as.matrix(table(a_nchild_dv, NR)))
plot(society$a_nchild_dv, society$NR)

society[society$a_respf16_dv=="Yes" & society$a_rach16_dv=="No",]

# model with all predictors
fullmodel <- glm(NR ~ a_gor_dv + a_urban_dv + a_sex + a_racel_dv + 
                   a_employ + a_dvage + a_agegr5_dv + a_agegr10_dv + a_agegr13_dv + 
                   a_mastat_dv + a_livesp_dv +  a_livewith + a_cohab_dv +
                   a_single_dv + a_depchl_dv + a_rach16_dv + a_resp16_dv + 
                   a_nchild_dv + hh_type + hh_size + n_child, family = binomial, data = society)

fullmodel$coefficients

# running this gives: fitted probabilities numerically 0 or 1 occured --> delete variables that create perfect separation..  (38 not defined because of singularities). Excluding those variables didn't lead to differnt outcomes, therefore we decided to leave them in. 

# model without any predictors
emptymodel <- nothing <- glm(NR ~ 
                             1,
                             family=binomial, data = society )
summary(emptymodel)

# backwards selection
backwards <- step(fullmodel)
summary(backwards)

# forwards selection to compare backwards model with it. 
forwards <- step(emptymodel,
scope=list(lower=formula(emptymodel),upper=formula(fullmodel)), direction="forward")

# show different models: 
formula(fullmodel)
formula(backwards)
```
