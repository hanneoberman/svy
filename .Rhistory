for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1)
# return statistics: possible permutations, t-statistic, p.value, empiral p.value.
#result <- matrix(c(tOriginal, pOriginal, possibleperms, p.empirical), 1, 4)
#colnames(result) <- c("original T", "p-value", "Possible permutations",  "empirical p-value")
#rownames(result) <- value
result2 <- data.frame(c(tOriginal, pOriginal, possibleperms, p.empirical), rownames = "value")
# also return histogram with
#return(result)
return(result2)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1)
#organize output: possible permutations, t-statistic, p.value, empiral p.value.
# result <- matrix(c(tOriginal, pOriginal, possibleperms, p.empirical), 1, 4)
# colnames(result) <- c("original T", "p-value", "Possible permutations",  "empirical p-value")
# rownames(result) <- value
result <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical)
# also return histogram with
return(result)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
heu$empirical.p
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1)
result <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical,
"histogram" = p1)
# also return histogram with
return(result)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
?list
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1)
result <- list("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical,
"histogram" = p1)
# also return histogram with
return(result)
}
result
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1)
resultsTable <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical,
"histogram" = p1)
# also return histogram with
output <- list("results" = resultsTable, "graph" = p1)
return(ouptut)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1) # print histogram (maybe also save it somewhere )
output <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical)
return(ouptut)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1) # print histogram (maybe also save it somewhere )
output <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical)
return(ouptut)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1) # print histogram (maybe also save it somewhere )
output <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical)
return(output)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1) # print histogram (maybe also save it somewhere )
output <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical, rownames = "value")
return(output)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
data.frame
?data.frame
# hypothesis test based on t.test() function:
myRandomizationTest <- function(x, y, B) { # x and y are your input groups, B is the number of permutations you want to sample
n <- length(x) # size group 1
m <- length(y) # size group 2
possibleperms <- factorial(n+m) / (factorial(n) * factorial(m))
tDist <- matrix(NA, B, 1) #matrix to store the mean differences in later.
resample <- matrix(NA, B, 18)
# in an ideal situation we would want to construct all possile permutations
# and from there construct a distribution of t-values. However, this is very
# time consuming when n gets large, therefore we choose to randomly resample B
# permutations from the sample, and from there construct an estimate. Given a
# large sample with a distribution, the random sampling will approximate the
# distribution.
for (i in 1:B) { # repeat B times -
# sample without replacement N observations from the sample with size N
resample[i,] <- sample(c(x,y), n+m, replace = FALSE) # We sample out of the possible permutations because calculation all possible permutations will take too long and sampling won't return inferior results.
# assign the first n1 observations to group 1 (size n1) and the remaining observations to group 2(size n2)
g1 <- resample[i,1:n]
g2 <- resample[i,(n+1):(n+m)]
# compute mean group 1 - mean group 2, store in a vector
tDist[i,] <- t.test(g1,g2)$statistic
}
# compute proportion of times the mean difference for each permutation
# where resampling t-statistic is larger (in absolute sense) than the mean difference of the
# original t-statistic (this variable = empirical p-value)
tOriginal <- t.test(x,y)$statistic
pOriginal <- t.test(x,y)$p.value
p.empirical <- mean(abs(tDist) > abs(tOriginal))
# plot distribution of mean differences (histogram) and place the original sample value in the histogram
require(ggplot2)
p1 <- ggplot(data=as.data.frame(tDist), aes(tDist)) +
geom_histogram(binwidth = 0.5,
col="lightskyblue3",
fill="lightskyblue1") +
geom_vline(xintercept = tOriginal, col = "lightsalmon", size = 1) +
labs(title="Permutation test on t-values (B permutations)") +
labs(x="distribution two sample t-statistic (of x and y)", y="Count") +
theme_light()
print(p1) # print histogram (maybe also save it somewhere )
output <- data.frame("original T" = tOriginal,
"original p" = pOriginal,
"Possible permutations" = possibleperms,
"empirical p" = p.empirical, row.names = "statistic")
return(output)
}
heu <- myRandomizationTest(CSFI, TFI, 10000)
heu
simulate.power <- function(n1, m1, sd1, n2, m2, sd2, i, alpha) {
# optional: adjust function for unequal variances)
p.values <- matrix(NA, i, 1)
for (i in 1:i) {
g1 <- rnorm(n1, m1, sd1) # create sample for group 1
g2 <- rnorm(n2, m2, sd2) # create sample for group 2
p.values[i,] <- t.test(g1, g2)$p.value # store p.value of t-statistic in a vector.
}
# compute power:
power <- mean(p.values < alpha) # compute proportion of times the p.value is below the alpha level, in other words: when H0 is correctly rejected.
results <- list(p.values = p.values, power = power)
}
test <- simulate.power(50, 150, 15, 50, 160, 15, 1000, alpha = .05)
test
simulate.power <- function(n1, m1, sd1, n2, m2, sd2, i, alpha) {
# optional: adjust function for unequal variances)
p.values <- matrix(NA, i, 1)
for (i in 1:i) {
g1 <- rnorm(n1, m1, sd1) # create sample for group 1
g2 <- rnorm(n2, m2, sd2) # create sample for group 2
p.values[i,] <- t.test(g1, g2)$p.value # store p.value of t-statistic in a vector.
}
# compute power:
power <- mean(p.values < alpha) # compute proportion of times the p.value is below the alpha level, in other words: when H0 is correctly rejected.
results <- list(p.values = p.values, power = power)
with(results, { # define what I want the function to print on the screen.
cat("power by simulation = \n")
print(power)
})
invisible(results)
}
test <- simulate.power(50, 150, 15, 50, 160, 15, 1000, alpha = .05)
test <- simulate.power(50, 150, 15, 50, 160, 15, 1000, alpha = .05)
test
test$power
# power by inbuilt R function
power.t.test(n = 50, delta = 10, sd = 15, sig.level = .05, power = NULL, alternative = "two.sided")
